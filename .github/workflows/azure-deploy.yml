name: Deploy to Azure App Service

on:
  push:
    branches:
      - main
      - master
  pull_request:
    branches:
      - main
      - master
  workflow_dispatch:

env:
  AZURE_WEBAPP_NAME_BACKEND: finagent-backend-pps457j4wjrc6
  AZURE_WEBAPP_NAME_FRONTEND: finagent-web-pps457j4wjrc6
  NODE_VERSION: '20.x'

jobs:
  build-and-deploy-backend:
    name: Build and Deploy Backend
    runs-on: ubuntu-latest
    environment:
      name: 'production'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}

    - name: Install pnpm
      uses: pnpm/action-setup@v2
      with:
        version: 9
        run_install: false

    - name: Get pnpm store directory
      shell: bash
      run: |
        echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

    - name: Setup pnpm cache
      uses: actions/cache@v3
      with:
        path: ${{ env.STORE_PATH }}
        key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
        restore-keys: |
          ${{ runner.os }}-pnpm-store-

    - name: Install dependencies
      run: |
        pnpm install --frozen-lockfile --filter=backend... || pnpm install --no-frozen-lockfile --filter=backend...

    - name: Build backend
      run: |
        pnpm run build --filter=backend || echo "Build script not found, skipping build"

    - name: Create deployment package
      run: |
        cd apps/backend
        # Remove Windows deployment files that cause issues on Linux
        rm -f .deployment deploy.cmd
        
        # Create a startup script for Azure Linux App Service
        cat > startup.sh << 'BACKEND_EOF'
        #!/bin/bash
        echo "Starting Motia backend application..."
        cd /home/site/wwwroot
        
        # Install dependencies if node_modules doesn't exist
        if [ ! -d "node_modules" ]; then
            echo "Installing dependencies..."
            npm ci --only=production
        fi
        
        # Install Motia CLI globally if not present
        if ! command -v motia &> /dev/null; then
            echo "Installing Motia CLI..."
            npm install -g motia@0.6.4-beta.130
        fi
        
        # Build the Motia project
        echo "Building Motia backend..."
        motia build || echo "Build completed or not required"
        
        # Start the application
        echo "Starting Motia on port \${PORT:-3001}..."
        motia start --port \${PORT:-3001} --host 0.0.0.0
        BACKEND_EOF
        
        chmod +x startup.sh
        
        # Create deployment package
        zip -r deploy.zip . \
          -x "*.git*" \
          -x "*node_modules*" \
          -x "*.env*" \
          -x "*test*" \
          -x "*.md" \
          -x ".DS_Store" \
          -x ".deployment" \
          -x "deploy.cmd"

    - name: Deploy to Azure Web App
      uses: azure/webapps-deploy@v3
      with:
        app-name: ${{ env.AZURE_WEBAPP_NAME_BACKEND }}
        publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE_BACKEND }}
        package: apps/backend/deploy.zip

  build-and-deploy-frontend:
    name: Build and Deploy Frontend
    runs-on: ubuntu-latest
    environment:
      name: 'production'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}

    - name: Install pnpm
      uses: pnpm/action-setup@v2
      with:
        version: 9
        run_install: false

    - name: Get pnpm store directory
      shell: bash
      run: |
        echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

    - name: Setup pnpm cache
      uses: actions/cache@v3
      with:
        path: ${{ env.STORE_PATH }}
        key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
        restore-keys: |
          ${{ runner.os }}-pnpm-store-

    - name: Install dependencies
      run: |
        pnpm install --frozen-lockfile --filter=web... || pnpm install --no-frozen-lockfile --filter=web...

    - name: Build frontend
      run: |
        cd apps/web
        pnpm build
      env:
        NEXT_PUBLIC_API_URL: https://${{ env.AZURE_WEBAPP_NAME_BACKEND }}.azurewebsites.net
        NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
        NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY }}
        SKIP_BUILD_PRODUCT_REDIRECTS: 1

    - name: Create deployment package
      run: |
        cd apps/web
        
        # Create deployment package with all necessary files
        mkdir -p deploy-package
        
        # Copy source files (needed for Azure build)
        cp -r src deploy-package/
        cp -r public deploy-package/ 2>/dev/null || true
        
        # Copy configuration files
        cp package.json deploy-package/
        cp pnpm-lock.yaml deploy-package/ 2>/dev/null || true
        cp package-lock.json deploy-package/ 2>/dev/null || true
        cp next.config.ts deploy-package/ 2>/dev/null || true
        cp next.config.js deploy-package/ 2>/dev/null || true
        cp tsconfig.json deploy-package/ 2>/dev/null || true
        cp tailwind.config.ts deploy-package/ 2>/dev/null || true
        cp postcss.config.mjs deploy-package/ 2>/dev/null || true
        
        # Copy built files if they exist (for faster deployment)
        cp -r .next deploy-package/ 2>/dev/null || true
        
        # Create server.js for Azure App Service
        cat > deploy-package/server.js << 'SERVER_EOF'
        const { createServer } = require('http');
        const { parse } = require('url');
        const next = require('next');
        
        const dev = process.env.NODE_ENV !== 'production';
        const hostname = '0.0.0.0';
        const port = process.env.PORT || 8080;
        
        const app = next({ dev, hostname, port });
        const handle = app.getRequestHandler();
        
        app.prepare().then(() => {
          createServer(async (req, res) => {
            try {
              const parsedUrl = parse(req.url, true);
              await handle(req, res, parsedUrl);
            } catch (err) {
              console.error('Error occurred handling', req.url, err);
              res.statusCode = 500;
              res.end('internal server error');
            }
          }).listen(port, (err) => {
            if (err) throw err;
            console.log(\`> Ready on http://\${hostname}:\${port}\`);
          });
        });
        SERVER_EOF
        
        # Create web.config for IIS
        cat > deploy-package/web.config << 'WEBCONFIG_EOF'
        <?xml version="1.0" encoding="utf-8"?>
        <configuration>
          <system.webServer>
            <handlers>
              <add name="iisnode" path="server.js" verb="*" modules="iisnode"/>
            </handlers>
            <rewrite>
              <rules>
                <rule name="DynamicContent">
                  <conditions>
                    <add input="{REQUEST_FILENAME}" matchType="IsFile" negate="True"/>
                  </conditions>
                  <action type="Rewrite" url="server.js"/>
                </rule>
              </rules>
            </rewrite>
            <iisnode node_env="production" />
          </system.webServer>
        </configuration>
        WEBCONFIG_EOF
        
        # Create a package.json for production if needed
        cd deploy-package
        
        # Create deployment package
        zip -r ../deploy.zip . \
          -x "*.git*" \
          -x "*.env*" \
          -x ".next/cache/*" \
          -x "*test*" \
          -x "*.md" \
          -x ".DS_Store"

    - name: Deploy to Azure Web App
      uses: azure/webapps-deploy@v3
      with:
        app-name: ${{ env.AZURE_WEBAPP_NAME_FRONTEND }}
        publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE_FRONTEND }}
        package: apps/web/deploy.zip

  configure-app-settings:
    name: Configure App Settings
    needs: [build-and-deploy-backend, build-and-deploy-frontend]
    runs-on: ubuntu-latest
    
    steps:
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Set Backend App Settings
      uses: azure/appservice-settings@v1
      with:
        app-name: ${{ env.AZURE_WEBAPP_NAME_BACKEND }}
        app-settings-json: |
          [
            {
              "name": "NODE_ENV",
              "value": "production"
            },
            {
              "name": "WEBSITE_NODE_DEFAULT_VERSION",
              "value": "~20"
            },
            {
              "name": "WEBSITE_STARTUP_FILE",
              "value": "startup.sh"
            },
            {
              "name": "SCM_DO_BUILD_DURING_DEPLOYMENT",
              "value": "false"
            },
            {
              "name": "ENABLE_ORYX_BUILD",
              "value": "false"
            },
            {
              "name": "WEBSITE_RUN_FROM_PACKAGE",
              "value": "0"
            },
            {
              "name": "POST_BUILD_COMMAND",
              "value": ""
            }
          ]

    - name: Set Frontend App Settings
      uses: azure/appservice-settings@v1
      with:
        app-name: ${{ env.AZURE_WEBAPP_NAME_FRONTEND }}
        app-settings-json: |
          [
            {
              "name": "NODE_ENV",
              "value": "production"
            },
            {
              "name": "WEBSITE_NODE_DEFAULT_VERSION",
              "value": "~20"
            },
            {
              "name": "WEBSITE_STARTUP_FILE",
              "value": "startup.sh"
            },
            {
              "name": "SCM_DO_BUILD_DURING_DEPLOYMENT",
              "value": "false"
            },
            {
              "name": "ENABLE_ORYX_BUILD",
              "value": "false"
            },
            {
              "name": "WEBSITE_RUN_FROM_PACKAGE",
              "value": "0"
            },
            {
              "name": "POST_BUILD_COMMAND",
              "value": ""
            }
          ]